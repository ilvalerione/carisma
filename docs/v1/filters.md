# Filters

[TOC]

Carisma filters allow you to fully customize the underlying resource Eloquent query. For example, you may want to list of all your application's users sorted by their total lifetime revenue. Creating such a list may require you to join to additional tables and perform aggregate functions within the query. If it sounds complicated, don't worry - this is exactly the type of situation filters are designed to solve.

## Defining Filter

To get started, you may use the `carisma:filter` Artisan command. By default, Carisma will place newly generated filters in the `app/Carisma/Fitlers` directory:

```shell
php artisan carisma:filter MostValuableUsers
```

In the filter class generated by Carisma the `query` method is responsible for building the Eloquent query that is needed to retrieve the desired data, while the `fields` method returns an array of fields that should be displayed when viewing the lens.

To learn more, let's take a look at a complete lens definition that displays users and their lifetime revenue:

```php
<?php

namespace App\Carisma\Filters;

use Illuminate\Http\Request;
use Carisma\Fields\Field;
use Carisma\Filters\Filter;
use Illuminate\Support\Facades\DB;
use Carisma\Http\Requests\FilterRequest;

class MostValuableUsers extends Filter
{
    /**
     * Get the query builder / paginator for the filter.
     *
     * @param  \Carisma\Http\Requests\FilterRequest  $request
     * @param  \Illuminate\Database\Eloquent\Builder  $query
     * @return mixed
     */
    public static function query(FilterRequest $request, $query)
    {
        return $request->withOrdering($request->withFilters(
            $query->select(self::columns())
                  ->join('licenses', 'users.id', '=', 'licenses.user_id')
                  ->orderBy('revenue', 'desc')
                  ->groupBy('users.id', 'users.name')
        ));
    }

    /**
     * Get the columns that should be selected.
     *
     * @return array
     */
    protected static function columns()
    {
        return [
            'users.id',
            'users.name',
            DB::raw('sum(licenses.price) as revenue'),
        ];
    }

    /**
     * Get the fields available to the filter.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return array
     */
    public function fields(Request $request)
    {
        return [
            Field::make('id'),
            Field::make('name'),

            Field::make('revenue')
            	->resolveUsing(function ($value) {
                    return '$'.number_format($value, 2);
                }),
        ];
    }
}
```

> {info} Columns Method
>
> In this example, the `columns` method has been extracted from the `query` method for readability. It is not "required" and is not a "feature" of lenses.

As you can see in the example above, the `query` method has full control of the Eloquent query used to retrieve the data. The `fields` method may leverage any of Carisma's fields in order to appropriately display the data retrieved by the query.

## Registering Filter

Once you have defined a filter, you are ready to attach it to a resource. Each resource generated by Carisma contains a `filters` method. To attach a filter to a resource, you should simply add it to the array of filters returned by this method:

```php
/**
 * Get the filters available for the resource.
 *
 * @param  \Illuminate\Http\Request $request
 * @return array
 */
public static function filters(Request $request)
{
    return [
    	new MostValuableUsers,
    ];
}
```

## Run filter

You can run the filter using endpoint `/{resource}/filters?filter=most_valuable_users` that allow you to run filters related to the given resource and get back paginated result.

As mentioned above you can use the "snake case" of the class name as filter's name in the uri parameter. If you want customize this value you can pass your custom name as first argument of your filter constructor:

```php
/**
 * Get the filters available for the resource.
 *
 * @param  \Illuminate\Http\Request $request
 * @return array
 */
public static function filters(Request $request)
{
    return [
        // Run filter using "/users/filters?filter=most-valuable&perPage=10"
    	new MostValuableUsers('most-valuable'),
    ];
}
```

## Authorization

If you would like to only expose a given filter to certain users, you may chain the `canRun` method onto your filter registration. The `canRun` method accepts a Closure which should return `true` or `false`. The Closure will receive the incoming HTTP request:

```php
use App\User;

/**
 * Get the filters available for the resource.
 *
 * @param  \Illuminate\Http\Request $request
 * @return array
 */
public static function filters(Request $request)
{
    return [
        (new MostValuableUsers)->canRun(function ($request){
            return $request->user()->can(
                'viewValuableUsers', User::class
            );
        }),
    ];
}
```

In the example above, we are using Laravel's `Authorizable` trait's `can` method on our `User` model to determine if the authorized user is authorized for the `viewValuableUsers` action. 

However, since proxying to authorization policy methods is a common use-case for `canRun`, you may use the `canRunWhen` method to achieve the same behavior. The `canRunWhen` method has the same method signature as the `Illuminate\Foundation\Auth\Access\Authorizable` trait's `can` method:

```php
/**
 * Get the filters available for the resource.
 *
 * @param  \Illuminate\Http\Request $request
 * @return array
 */
public static function filters(Request $request)
{
    return [
        (new MostValuableUsers)
        	->canRunWhen('viewValuableUsers', $this),
    ];
}
```

